<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Chart Insights Rating (Per-Item Submit)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- React & ReactDOM (UMD) -->
    <script
      src="https://unpkg.com/react@18/umd/react.development.js"
      crossorigin
    ></script>
    <script
      src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"
      crossorigin
    ></script>

    <!-- Emotion (for MUI v5) -->
    <script
      src="https://unpkg.com/@emotion/react@11.11.4/dist/emotion-react.umd.min.js"
      crossorigin
    ></script>
    <script
      src="https://unpkg.com/@emotion/styled@11.11.5/dist/emotion-styled.umd.min.js"
      crossorigin
    ></script>

    <!-- MUI v5 (UMD) -->
    <script
      src="https://unpkg.com/@mui/material@5.15.14/umd/material-ui.development.js"
      crossorigin
    ></script>
    <script
      src="https://unpkg.com/@mui/icons-material@5.15.14/umd/material-ui-icons.development.js"
      crossorigin
    ></script>

    <!-- Papa Parse for CSV -->
    <script
      src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"
      crossorigin
    ></script>

    <style>
      html,
      body,
      #root {
        height: 100%;
        margin: 0;
      }

      /* Make the chart much smaller & centered */
      img.chart {
        max-width: 100%;
        height: auto;
        display: block;
        margin: 0 auto;
      }

      .sticky-footer {
        position: sticky;
        bottom: 0;
        z-index: 10;
        background: rgba(255, 255, 255, 0.9);
        backdrop-filter: blur(6px);
      }

      #root strong {
        font-weight: 700;
      }
    </style>
  </head>

  <body>
    <div id="root"></div>

    <script>
      (() => {
        const { createElement: h, useEffect, useMemo, useState } = React;
        const {
          ThemeProvider,
          createTheme,
          CssBaseline,
          Container,
          Box,
          Typography,
          Grid,
          Card,
          CardHeader,
          CardContent,
          CardActions,
          Button,
          Rating,
          LinearProgress,
          Stack,
          Divider,
          Chip,
          Snackbar,
          Alert,
          Tooltip,
          TextField,
        } = MaterialUI;

        // ========= CONFIG =========

        const COMPLETION_URL =
          "https://app.prolific.com/submissions/complete?cc=CIWUGPOW"; // 用你在 Prolific 里生成的完成码替换
        const qp = new URLSearchParams(location.search);

        const PROLIFIC_PID =
          qp.get("PROLIFIC_PID") || localStorage.getItem("prolific_pid") ||  crypto.randomUUID();
        const STUDY_ID =
          qp.get("STUDY_ID") || localStorage.getItem("study_id") || "";
        const SESSION_ID =
          qp.get("SESSION_ID") || localStorage.getItem("session_id") || "";

        if (PROLIFIC_PID) localStorage.setItem("prolific_pid", PROLIFIC_PID);
        if (STUDY_ID) localStorage.setItem("study_id", STUDY_ID);
        if (SESSION_ID) localStorage.setItem("session_id", SESSION_ID);

        if (!PROLIFIC_PID) {
          console.warn(
            "No PROLIFIC_PID in URL; participant may not have come from Prolific."
          );
        }
        const REQUIRE_REASON = true;
        const TOTAL_CHARTS = 50;
        const PICK_COUNT = 10;
        const CHART_DIR = "./charts"; // charts/1.svg ... charts/50.svg
        const INSIGHTS_CSV_PATH = CHART_DIR + "/insights.csv"; // columns: id,insightA,insightB

        // !!! Replace with your public collector endpoint (e.g., ngrok) !!!
        const SUBMIT_URL = "https://858a084a6e68.ngrok-free.app/submit";
        // ==========================

        // Randomly sample k from [1..n]
        function randSample(n, k) {
          const arr = Array.from({ length: n }, (_, i) => i); // 1..n
          for (let i = arr.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
          }
          return arr.slice(0, k);
        }

        // Remove specific section labels from the ORIGINAL insightA text only
        function escapeRegExp(s) {
          return String(s).replace(/[.*+?^${}()|[\\]\\]/g, "\\$&");
        }

        function cleanInsightA(text) {
          if (!text) return "";
          let out = String(text).replace(/\r\n?/g, "\n");

          const LABELS = [
            "Observation of the Chart",
            "Visual Trend Analysis",
            "Statistical Analysis Summary",
            "Integrated Findings",
            "Overall Insight Summary",
          ];

          const NEED_LEADING_NL = new Set([
            "Visual Trend Analysis",
            "Statistical Analysis Summary",
            "Integrated Findings",
            "Overall Insight Summary",
          ]);

          // 1) Normalize each label to `Label:\n` and add a leading newline
          //    ONLY for the 4 specified labels (works even if labels are mid-line).
          for (const label of LABELS) {
            const before = NEED_LEADING_NL.has(label) ? "\n" : "";
            const re = new RegExp(
              `\\s*"?${escapeRegExp(label)}"?\\s*:\\s*`,
              "gi"
            );
            out = out.replace(re, `${before}${label}:\n`);
          }

          for (const label of LABELS) {
            const keep = NEED_LEADING_NL.has(label) ? "\n" : "";
            const re = new RegExp(
              `(^|\\n)\\s*${escapeRegExp(label)}\\s*:\\s*\\n`,
              "g"
            );
            out = out.replace(re, `$1${keep}`);
          }

          // 3) Strip surrounding quotes from each line BUT keep empty lines.
          out = out
            .split("\n")
            .map((line) => {
              let t = line.trimEnd(); // keep leading empties intact
              t = t.replace(/,\s*$/, ""); // drop trailing comma
              t = t.replace(/^[“"]+/, "").replace(/[”"]+$/, "");
              t = t
                .trim()
                .replace(/^"(.+)"$/, "$1")
                .replace(/^“(.+)”$/, "$1");
              return t;
            })
            .join("\n");

          out = out.replace(/\n{3,}/g, "\n\n").replace(/^\n+|\n+$/g, "");

          return out;
        }

        function escapeHtml(s) {
          return String(s)
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#39;");
        }

        function mdBoldToHtml(s) {
  if (!s) return "";
  const escaped = escapeHtml(String(s));
  return escaped
    .replace(/(^|\n)\s*#+\s*/g, "$1") 
    .replace(/\*\*/g, "") 
    .replace(/\n/g, "<br/>");
}
        // Stable child component to avoid remounting (prevents input jumping)
        function CurrentCard({
          items,
          currentIndex,
          handleRate,
          handleReason,
          handleSubmitCurrent,
          submitting,
        }) {
          const it = items[currentIndex];
          if (!it) return null;
          const displayNumber = currentIndex + 1;
          return h(
            Grid,
            { container: true, spacing: 3, justifyContent: "center" },
            h(
              Grid,
              { item: true, xs: 12, md: 10 },
              h(
                Card,
                null,
                h(
                  CardContent,
                  null,
                  h(
                    Box,
                    { sx: { mb: 2 } },
                    h("img", {
                      className: "chart",
                      src: it.imgUrl,
                      alt: `Chart ${displayNumber}`,
                      loading: "lazy",
                      onError: (e) => {
                        e.currentTarget.style.opacity = 0.2;
                      },
                    })
                  ),
                  // Side-by-side layout for Insight A and B
                  h(
                    Grid,
                    { container: true, spacing: 2, alignItems: "stretch" },
                    h(
                      Grid,
                      { item: true, xs: 12, md: 5 },
                      h(
                        Stack,
                        { spacing: 1 },
                        h(Typography, { variant: "subtitle2" }, "Insight A"),
                        // Render **bold** if present (avoids confusion when A/B are swapped)
                        h(Typography, {
                          variant: "body2",
                          sx: { mb: 1, wordBreak: "break-word" },
                          color: "text.primary",
                          dangerouslySetInnerHTML: {
                            __html: mdBoldToHtml(it.displayA),
                          },
                        }),
                        h(Rating, {
                          name: `ratingA-${displayNumber}`,
                          value: it.ratingA || 0,
                          onChange: (_, v) => handleRate("ratingA", v || 0),
                          disabled: it.submitted,
                        })
                      )
                    ),

                    h(
                      Grid,
                      {
                        item: true,
                        xs: 12,
                        md: 2,
                        sx: {
                          display: { xs: "none", md: "flex" },
                          alignItems: "center",
                          justifyContent: "center",
                        },
                      },
                      h(Chip, { label: "VS" })
                    ),

                    h(
                      Grid,
                      { item: true, xs: 12, md: 5 },
                      h(
                        Stack,
                        { spacing: 1 },
                        h(Typography, { variant: "subtitle2" }, "Insight B"),

                        h(Typography, {
                          variant: "body2",
                          sx: { mb: 1, wordBreak: "break-word" },
                          color: "text.primary",
                          dangerouslySetInnerHTML: {
                            __html: mdBoldToHtml(it.displayB),
                          },
                        }),
                        h(Rating, {
                          name: `ratingB-${displayNumber}`,
                          value: it.ratingB || 0,
                          onChange: (_, v) => handleRate("ratingB", v || 0),
                          disabled: it.submitted,
                        })
                      )
                    )
                  ),

                  h(
                    Box,
                    { sx: { display: { xs: "block", md: "none" }, my: 1 } },
                    h(Divider, null, h(Chip, { label: "VS" }))
                  ),
                  h(
                    Box,
                    { sx: { mt: 2 } },
                    h(TextField, {
                      label:
                        "Please explain the reasons behind your rating (1-5) for Insight A and Insight B, which are machine-generated data insights based on the given chart.",
                      placeholder:
                        "Write your reasoning (e.g., which insight is clearer, better supported, more persuasive, etc.)",
                      value: it.reason || "",
                      onChange: (e) => handleReason(e.target.value),
                      multiline: true,
                      minRows: 2,
                      fullWidth: true,
                      disabled: it.submitted,
                      InputLabelProps: { style: { whiteSpace: "pre-line" } },
                      required: REQUIRE_REASON, // ★ 新增
                      helperText: String(it.reason || "").trim()
                        ? ""
                        : "Please provide a brief reason (required to submit).",
                      FormHelperTextProps: { sx: { color: "text.secondary" } },
                    })
                  )
                ),
                h(
                  CardActions,
                  { sx: { justifyContent: "space-between" } },
                  h(
                    Typography,
                    { variant: "caption", color: "text.secondary" },
                    it.submitted
                      ? `Submitted: A=${it.ratingA} · B=${it.ratingB}`
                      : it.ratingA && it.ratingB
                      ? `Ready to submit: A=${it.ratingA} · B=${it.ratingB}`
                      : "Please rate both A and B"
                  ),
                  h(
                    Stack,
                    { direction: "row", spacing: 1 },
                    h(
                      Button,
                      {
                        variant: "outlined",
                        onClick: () => history.back(),
                        sx: { display: "none" },
                      },
                      "Back (hidden)"
                    ),
                    h(
                      Tooltip,
                      {
                        title:
                          !it.ratingA || !it.ratingB
                            ? "Rate both A and B to submit"
                            : it.submitted
                            ? "Already submitted"
                            : "",
                      },
                      h(
                        Box,
                        null,
                        h(
                          Button,
                          {
                            variant: "contained",
                            onClick: () => handleSubmitCurrent(),
                            disabled:
                              !it.ratingA ||
                              !it.ratingB ||
                              it.submitted ||
                              (REQUIRE_REASON &&
                                !String(it.reason || "").trim()),
                          },
                          submitting
                            ? "Submitting..."
                            : it.submitted
                            ? "Submitted"
                            : "Submit"
                        )
                      )
                    )
                  )
                )
              )
            )
          );
        }

        function useInsights() {
          const [loading, setLoading] = useState(true);
          const [error, setError] = useState(null);
          const [rows, setRows] = useState([]);

          useEffect(() => {
            Papa.parse(INSIGHTS_CSV_PATH, {
              download: true,
              header: true,
              skipEmptyLines: true,
              complete: (res) => {
                const valid = [];
                for (const r of res.data) {
                  const id = parseInt(r.id, 10);
                  if (!isNaN(id) && r.insightA && r.insightB) {
                    valid.push({
                      id,
                      insightA: String(r.insightA),
                      insightB: String(r.insightB),
                    });
                  }
                }
                setRows(valid);
                setLoading(false);
              },
              error: (err) => {
                setError(err?.message || "Failed to load CSV");
                setLoading(false);
              },
            });
          }, []);

          return { loading, error, rows };
        }

        function App() {
          const theme = useMemo(
            () =>
              createTheme({
                palette: { mode: "light" },
                shape: { borderRadius: 16 },
                      typography: {
        fontSize: 17, 
      },
              }),
            []
          );
          const { loading, error, rows } = useInsights();

          const [items, setItems] = useState([]);
          const [currentIndex, setCurrentIndex] = useState(0); // index of the currently displayed chart (1..10 shown to user)

          const [submitting, setSubmitting] = useState(false);
          const [snackbar, setSnackbar] = useState(null);
          const prevIndexRef = React.useRef(null);

          useEffect(() => {
            setItems((prev) => {
              if (!prev.length) return prev;
              const copy = prev.slice();
              const cur = copy[currentIndex];

              if (cur && !cur.submitted && cur.firstOpenPerf == null) {
                copy[currentIndex] = {
                  ...cur,
                  firstOpenPerf: performance.now(),
                  firstViewAtISO:
                    cur.firstViewAtISO || new Date().toISOString(),
                };
              }
              return copy;
            });
            prevIndexRef.current = currentIndex;
          }, [currentIndex]);
          useEffect(() => {
            if (!loading && !error && items.length) {
              setItems((prev) => {
                const copy = prev.slice();
                const first = copy[0];
                if (first && !first.submitted && first.firstOpenPerf == null) {
                  copy[0] = {
                    ...first,
                    firstOpenPerf: performance.now(),
                    firstViewAtISO: new Date().toISOString(),
                  };
                }
                return copy;
              });
            }
          }, [loading, error, items.length]);
          // Initialize selection
          useEffect(() => {
            if (!loading && !error && rows.length) {
              const maxN = Math.min(TOTAL_CHARTS, rows.length);
              const ids = randSample(maxN, PICK_COUNT);
              const map = new Map(rows.map((r) => [r.id, r]));
              const picked = ids.map((id) => {
                const rec = map.get(id) || {
                  insightA: `Insight A for #${id}`,
                  insightB: `Insight B for #${id}`,
                };

                // Clean ORIGINAL A only, then (optionally) swap A and B for display
                const originalA = cleanInsightA(rec.insightA);
                const originalB = String(rec.insightB);

                let displayA = originalA;
                let displayB = originalB;
                let swapped = false;
                if (Math.random() < 0.5) {
                  // Randomly swap A/B order (hidden from users)
                  [displayA, displayB] = [displayB, displayA];
                  swapped = true;
                }

                return {
                  id, // underlying chart id (NOT shown to users)
                  imgUrl: `${CHART_DIR}/${id}.svg`,

                  // store originals for submission mapping
                  originalA,
                  originalB,

                  // what is shown to the user
                  displayA,
                  displayB,
                  swapped,

                  // ratings captured by what the user sees as A/B
                  ratingA: null,
                  ratingB: null,
                  reason: "", // user free-text reason per chart
                  submitted: false, // per-item submit state

                  firstOpenPerf: null,
                  firstViewAtISO: null,
                  completedAtISO: null,
                };
              });
              setItems(picked);
              setCurrentIndex(0);
            }
          }, [loading, error, rows]);

          // Progress = proportion of submitted items
          const progress = useMemo(() => {
            const submittedCount = items.reduce(
              (acc, it) => acc + (it.submitted ? 1 : 0),
              0
            );
            const total = items.length || 1;
            return Math.round((submittedCount / total) * 100);
          }, [items]);

          // Expose prev for button inside card (so child stays pure)
          window.appHandlePrev = () =>
            setCurrentIndex((i) => Math.max(0, i - 1));

          // Rate current item
          function handleRate(field, value) {
            setItems((prev) => {
              const copy = prev.slice();
              const curr = { ...copy[currentIndex], [field]: value || 0 };
              copy[currentIndex] = curr;
              return copy;
            });
          }

          // Reason input for current item
          function handleReason(value) {
            setItems((prev) => {
              const copy = prev.slice();
              const curr = { ...copy[currentIndex], reason: value };
              copy[currentIndex] = curr;
              return copy;
            });
          }

          function mapRatingsToOriginal(it) {
            // User rated displayA/displayB. If swapped, displayA==originalB.
            if (!it.swapped) {
              return { ratingA: it.ratingA, ratingB: it.ratingB };
            } else {
              return { ratingA: it.ratingB, ratingB: it.ratingA };
            }
          }

          // Submit only the current item
          async function handleSubmitCurrent() {
            const it = items[currentIndex];
            if (submitting) return;
            if (!it || it.submitted || !it.ratingA || !it.ratingB) return;

            if (REQUIRE_REASON && !String(it.reason || "").trim()) {
              setSnackbar({
                severity: "warning",
                msg: "Please fill in the reasoning before submitting.",
              });
              return;
            }

            const durationMs =
              it.firstOpenPerf != null
                ? Math.round(performance.now() - it.firstOpenPerf)
                : 0;
            const completedAtISO = new Date().toISOString();
            const mapped = mapRatingsToOriginal(it);
            const payload = {
              submissionId:
                crypto && crypto.randomUUID
                  ? crypto.randomUUID()
                  : `id-${Date.now()}-${Math.random().toString(36).slice(2)}`,
              createdAt: new Date().toISOString(),
              timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
              userAgent: navigator.userAgent,
              selectedCharts: [it.id],
              responses: [
                {
                  chartId: it.id,
                  insightA: it.originalA,
                  ratingA: mapped.ratingA,
                  insightB: it.originalB,
                  ratingB: mapped.ratingB,
                  reason: it.reason,
                  _swapped: it.swapped,

                  durationMs,
                  firstViewAtISO: it.firstViewAtISO,
                  completedAtISO,
                },
              ],
              prolific: {
                pid: PROLIFIC_PID,
                studyId: STUDY_ID,
                sessionId: SESSION_ID,
              },
            };

            setSubmitting(true);
            try {
              if (!SUBMIT_URL || SUBMIT_URL.includes("YOUR-NGROK-SUBDOMAIN")) {
                throw new Error("SUBMIT_URL not configured yet");
              }
              const res = await fetch(SUBMIT_URL, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload),
              });
              if (!res.ok) throw new Error(`Submit failed: ${res.status}`);

              // Mark current item as submitted and advance to the next unsubmitted item
              setItems((prev) => {
                const copy = prev.slice();
                copy[currentIndex] = {
                  ...copy[currentIndex],
                  submitted: true,
                  lastViewStart: null,
                  completedAtISO,
                };
                return copy;
              });

              setSnackbar({
                severity: "success",
                msg: `Item #${currentIndex + 1} submitted in ${(
                  durationMs / 1000
                ).toFixed(1)}s.`,
              });

              setCurrentIndex((idx) => {
                const nextIdx = items.findIndex(
                  (x, i) => i > idx && !x.submitted && i !== idx
                );
                if (nextIdx !== -1) return nextIdx;
                return Math.min(idx + 1, items.length - 1);
              });
            } catch (e) {
              console.warn(e);
              setSnackbar({
                severity: "warning",
                msg: "Could not reach the server. Please check SUBMIT_URL.",
              });
            } finally {
              setSubmitting(false);
            }
          }

          const allSubmitted =
            items.length > 0 && items.every((it) => it.submitted);

          return h(
            ThemeProvider,
            { theme },
            h(CssBaseline, null),
            h(
              Box,
              { sx: { width: "100%", px: 2 } }, // slightly narrower overall UI
              h(
                Stack,
                { spacing: 2 },

                loading &&
                  h(
                    Box,
                    null,
                    h(LinearProgress, null),
                    h(
                      Typography,
                      { variant: "body2", sx: { mt: 1 } },
                      "Loading charts & insights..."
                    )
                  ),
                error && h(Alert, { severity: "error" }, String(error)),

                !loading &&
                  !error &&
                  items.length > 0 &&
                  h(
                    Box,
                    null,
                    h(CurrentCard, {
                      items,
                      currentIndex,
                      handleRate,
                      handleReason,
                      handleSubmitCurrent,
                      submitting,
                    }),

                    // Bottom controls (sticky at page bottom): Progress only. (Global Submit removed)
                    h(
                      Box,
                      { className: "sticky-footer", sx: { py: 1, mt: 2 } },
                      h(
                        Stack,
                        { direction: "row", alignItems: "center", spacing: 2 },
                        h(
                          Box,
                          { sx: { flex: 1 } },
                          h(LinearProgress, {
                            variant: "determinate",
                            value: progress,
                          }),
                          h(
                            Typography,
                            { variant: "caption", color: "text.secondary" },
                            allSubmitted
                              ? "All items submitted — thank you!"
                              : `${progress}% complete`
                          )
                        ),
                        // NOTE: Removed the old global Submit button as requested.
                        allSubmitted
                          ? h(
                              Button,
                              {
                                variant: "contained",
                                color: "success",
                                onClick: () => {
                                  window.location.href = COMPLETION_URL;
                                },
                              },
                              "Finish & return to Prolific"
                            )
                          : h(Box)
                      )
                    )
                  )
              ),
              h(
                Snackbar,
                {
                  open: !!snackbar,
                  autoHideDuration: 4000,
                  onClose: () => setSnackbar(null),
                  anchorOrigin: { vertical: "bottom", horizontal: "center" },
                },
                snackbar &&
                  h(
                    Alert,
                    { severity: snackbar.severity, variant: "filled" },
                    snackbar.msg
                  )
              )
            )
          );
        }

        const root = ReactDOM.createRoot(document.getElementById("root"));
        root.render(React.createElement(App));
      })();
    </script>
  </body>
</html>
