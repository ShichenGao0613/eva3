<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Chart Insights Rating (Sequential)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- React & ReactDOM (UMD) -->
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>

  <!-- Emotion (for MUI v5) -->
  <script src="https://unpkg.com/@emotion/react@11.11.4/dist/emotion-react.umd.min.js" crossorigin></script>
  <script src="https://unpkg.com/@emotion/styled@11.11.5/dist/emotion-styled.umd.min.js" crossorigin></script>

  <!-- MUI v5 (UMD) -->
  <script src="https://unpkg.com/@mui/material@5.15.14/umd/material-ui.development.js" crossorigin></script>
  <script src="https://unpkg.com/@mui/icons-material@5.15.14/umd/material-ui-icons.development.js" crossorigin></script>

  <!-- Papa Parse for CSV -->
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js" crossorigin></script>

  <style>
    html, body, #root { height: 100%; margin: 0; }
    /* Smaller chart image and centered */
    img.chart {
      width: 100%;
      max-width: 760px; /* adjust this number to make the chart smaller/larger */
      height: auto;
      border-radius: 12px;
      display: block;
      margin: 0 auto;
      background: #f5f5f5;
    }
    .sticky-footer { position: sticky; bottom: 0; z-index: 10; background: rgba(255,255,255,0.9); backdrop-filter: blur(6px); }
  </style>
</head>
<body>
<div id="root"></div>

<script>
(() => {
  const { createElement: h, useEffect, useMemo, useState } = React;
  const {
    ThemeProvider, createTheme, CssBaseline, Container, Box, Typography, Grid,
    Card, CardHeader, CardContent, CardActions, Button, Rating, LinearProgress,
    Stack, Divider, Chip, Snackbar, Alert, Tooltip
  } = MaterialUI;

  // ========= CONFIG =========
  const TOTAL_CHARTS = 50;
  const PICK_COUNT = 10;
  const CHART_DIR = './charts';               // charts/1.svg ... charts/50.svg
  const INSIGHTS_CSV_PATH = CHART_DIR + '/insights.csv'; // columns: id,insightA,insightB

  // !!! Replace with your public collector endpoint (e.g., ngrok) !!!
  const SUBMIT_URL = 'https://abc123.ngrok.io/submit';
  // ==========================

  // Randomly sample k from [1..n]
  function randSample(n, k) {
    const arr = Array.from({length: n}, (_, i) => i + 1); // 1..n
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr.slice(0, k);
  }

  function useInsights() {
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    const [rows, setRows] = useState([]);

    useEffect(() => {
      Papa.parse(INSIGHTS_CSV_PATH, {
        download: true,
        header: true,
        skipEmptyLines: true,
        complete: (res) => {
          const valid = [];
          for (const r of res.data) {
            const id = parseInt(r.id, 10);
            if (!isNaN(id) && r.insightA && r.insightB) {
              valid.push({ id, insightA: String(r.insightA), insightB: String(r.insightB) });
            }
          }
          setRows(valid);
          setLoading(false);
        },
        error: (err) => {
          setError(err?.message || 'Failed to load CSV');
          setLoading(false);
        }
      });
    }, []);

    return { loading, error, rows };
  }

  function App() {
    const theme = useMemo(() => createTheme({ palette: { mode: 'light' }, shape: { borderRadius: 16 } }), []);
    const { loading, error, rows } = useInsights();

    const [items, setItems] = useState([]);
    const [currentIndex, setCurrentIndex] = useState(0); // index of the currently displayed chart
    const [completed, setCompleted] = useState(false);   // all charts rated (auto-complete)

    const [submitting, setSubmitting] = useState(false);
    const [snackbar, setSnackbar] = useState(null);

    const allRated = items.length > 0 && items.every(it => it.ratingA && it.ratingB);

    // Initialize selection
    useEffect(() => {
      if (!loading && !error && rows.length) {
        const maxN = Math.min(TOTAL_CHARTS, rows.length);
        const ids = randSample(maxN, PICK_COUNT);
        const map = new Map(rows.map(r => [r.id, r]));
        const picked = ids.map(id => {
          const rec = map.get(id) || { insightA: `Insight A for #${id}`, insightB: `Insight B for #${id}` };
          return {
            id,
            imgUrl: `${CHART_DIR}/${id}.svg`,
            insightA: rec.insightA,
            insightB: rec.insightB,
            ratingA: null,
            ratingB: null
          };
        });
        setItems(picked);
        setCurrentIndex(0);
        setCompleted(false);
      }
    }, [loading, error, rows]);

    // Progress (2 ratings per item)
    const progress = useMemo(() => {
      const rated = items.reduce((acc, it) => acc + (it.ratingA ? 1 : 0) + (it.ratingB ? 1 : 0), 0);
      const total = items.length * 2 || 1;
      return Math.round((rated / total) * 100);
    }, [items]);

    // Rate current item
    function handleRate(field, value) {
      setItems(prev => {
        const copy = prev.slice();
        const curr = { ...copy[currentIndex], [field]: value || 0 };
        copy[currentIndex] = curr;
        return copy;
      });
    }

    // Manual navigation
    function handlePrev() {
      setCurrentIndex(i => Math.max(0, i - 1));
    }
    function handleNext() {
      setCurrentIndex(i => Math.min(items.length - 1, i + 1));
    }

    // Auto-advance when both A & B are rated
    useEffect(() => {
      if (!items.length || completed) return;
      const curr = items[currentIndex];
      if (curr && curr.ratingA && curr.ratingB) {
        if (currentIndex < items.length - 1) {
          const t = setTimeout(() => setCurrentIndex(i => i + 1), 250);
          return () => clearTimeout(t);
        } else {
          const t = setTimeout(() => setCompleted(true), 250);
          return () => clearTimeout(t);
        }
      }
    }, [items, currentIndex, completed]);

    async function handleSubmit() {
      if (!allRated) return;

      const payload = {
        submissionId: (crypto && crypto.randomUUID) ? crypto.randomUUID() : `id-${Date.now()}-${Math.random().toString(36).slice(2)}`,
        createdAt: new Date().toISOString(),
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        userAgent: navigator.userAgent,
        selectedCharts: items.map(it => it.id),
        responses: items.map(it => ({
          chartId: it.id,
          insightA: it.insightA,
          ratingA: it.ratingA,
          insightB: it.insightB,
          ratingB: it.ratingB
        }))
      };

      setSubmitting(true);
      try {
        if (!SUBMIT_URL || SUBMIT_URL.includes('YOUR-NGROK-SUBDOMAIN')) {
          throw new Error('SUBMIT_URL not configured yet');
        }
        const res = await fetch(SUBMIT_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });
        if (!res.ok) throw new Error(`Submit failed: ${res.status}`);
        setSnackbar({ severity: 'success', msg: 'Thanks! Your ratings were submitted.' });
      } catch (e) {
        console.warn(e);
        setSnackbar({ severity: 'warning', msg: 'Could not reach server. Check SUBMIT_URL.' });
      } finally {
        setSubmitting(false);
      }
    }

    // ======= UI =======
    const CurrentCard = () => {
      const it = items[currentIndex];
      if (!it) return null;
      return h(Grid, { container: true, spacing: 3 },
        h(Grid, { item: true, xs: 12, md: 10 },
          h(Card, null,
            h(CardHeader, { title: `Chart #${it.id}`, subheader: `Item ${currentIndex + 1} of ${items.length} (rate A and B)` }),
            h(CardContent, null,
              h(Box, { sx: { mb: 2 } },
                h('img', {
                  className: 'chart', src: it.imgUrl, alt: `Chart ${it.id}`, loading: 'lazy',
                  onError: (e) => { e.currentTarget.style.opacity = 0.2; }
                })
              ),

              // Side-by-side layout for Insight A and B
              h(Grid, { container: true, spacing: 2, alignItems: 'stretch' },
                h(Grid, { item: true, xs: 12, md: 5 },
                  h(Stack, { spacing: 1 },
                    h(Typography, { variant: 'subtitle2' }, 'Insight A'),
                    h(Typography, { variant: 'body2', sx: { mb: 1, whiteSpace: 'pre-line', wordBreak: 'break-word' }, color: 'text.secondary' }, it.insightA),
                    h(Rating, {
                      name: `ratingA-${it.id}`,
                      value: it.ratingA || 0,
                      onChange: (_, v) => handleRate('ratingA', v || 0)
                    })
                  )
                ),

                // VS for desktop (hidden on mobile)
                h(Grid, { item: true, xs: 12, md: 2, sx: { display: { xs: 'none', md: 'flex' }, alignItems: 'center', justifyContent: 'center' } },
                  h(Chip, { label: 'VS' })
                ),

                h(Grid, { item: true, xs: 12, md: 5 },
                  h(Stack, { spacing: 1 },
                    h(Typography, { variant: 'subtitle2' }, 'Insight B'),
                    h(Typography, { variant: 'body2', sx: { mb: 1, whiteSpace: 'pre-line', wordBreak: 'break-word' }, color: 'text.secondary' }, it.insightB),
                    h(Rating, {
                      name: `ratingB-${it.id}`,
                      value: it.ratingB || 0,
                      onChange: (_, v) => handleRate('ratingB', v || 0)
                    })
                  )
                )
              ),

              // VS for mobile (between stacked sections)
              h(Box, { sx: { display: { xs: 'block', md: 'none' }, my: 1 } },
                h(Divider, null, h(Chip, { label: 'VS' }))
              )
            ),
            h(CardActions, { sx: { justifyContent: 'space-between' } },
              h(Typography, { variant: 'caption', color: 'text.secondary' },
                (it.ratingA && it.ratingB) ? `Rated: A=${it.ratingA} · B=${it.ratingB} (next chart will appear)` : 'Please rate both A and B'
              ),
              h(Typography, { variant: 'caption', color: 'text.secondary' }, `#${it.id}`)
            )
          )
        )
      );
    };

    const DoneCard = () => (
      h(Grid, { container: true, spacing: 3 },
        h(Grid, { item: true, xs: 12, md: 10 },
          h(Card, null,
            h(CardHeader, { title: 'All done 🎉', subheader: 'You can now submit your 10 ratings.' }),
            h(CardContent, null,
              h(Typography, { variant: 'body1', sx: { mb: 1 } }, 'Click Submit below to send your responses.'),
              h(Typography, { variant: 'body2', color: 'text.secondary' }, 'You can also use your browser back/forward history to review previous items before submitting.')
            )
          )
        )
      )
    );

    return h(ThemeProvider, { theme },
      h(CssBaseline, null),
      h(Container, { maxWidth: 'xl', sx: { py: 4 } }, // wider overall UI
        h(Stack, { spacing: 2 },
          h(Box, null,
            h(Typography, { variant: 'h4', sx: { fontWeight: 700 } }, 'Chart Insights Rating'),
            h(Typography, { variant: 'subtitle1', color: 'text.secondary' },
              'Only one chart is shown at a time. After you rate Insight A and Insight B, the next chart will automatically appear.'
            )
          ),

          (loading) && h(Box, null, h(LinearProgress, null), h(Typography, { variant: 'body2', sx: { mt: 1 } }, 'Loading charts & insights...')),
          (error) && h(Alert, { severity: 'error' }, String(error)),

          (!loading && !error && items.length > 0) && h(Box, null,
            h(Box, { className: 'sticky-footer', sx: { py: 1, mb: 2 } },
              h(Stack, { direction: 'row', alignItems: 'center', spacing: 2 },
                h(Box, { sx: { flex: 1 } },
                  h(LinearProgress, { variant: 'determinate', value: progress }),
                  h(Typography, { variant: 'caption', color: 'text.secondary' }, `${progress}% complete`)
                ),

                // New Previous / Next buttons
                h(Stack, { direction: 'row', spacing: 1 },
                  h(Button, { variant: 'outlined', onClick: handlePrev, disabled: currentIndex === 0 }, 'Previous'),
                  h(Button, { variant: 'outlined', onClick: handleNext, disabled: currentIndex >= items.length - 1 }, 'Next')
                ),

                h(Tooltip, { title: SUBMIT_URL.includes('YOUR-NGROK-SUBDOMAIN') ? 'Configure SUBMIT_URL to enable server submission' : '' },
                  h(Box, null,
                    h(Button, { variant: 'contained', disabled: !allRated || submitting, onClick: handleSubmit },
                      submitting ? 'Submitting...' : 'Submit'
                    )
                  )
                )
              )
            ),

            completed ? h(DoneCard, null) : h(CurrentCard, null)
          )
        ),
        h(Snackbar, {
          open: !!snackbar, autoHideDuration: 4000,
          onClose: () => setSnackbar(null), anchorOrigin: { vertical: 'bottom', horizontal: 'center' }
        }, snackbar && h(Alert, { severity: snackbar.severity, variant: 'filled' }, snackbar.msg))
      )
    );
  }

  const root = ReactDOM.createRoot(document.getElementById('root'));
  root.render(React.createElement(App));
})();
</script>
</body>
</html>