<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Chart Insights Rating (Simple)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- React & ReactDOM (UMD) -->
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>

  <!-- Emotion (for MUI v5) -->
  <script src="https://unpkg.com/@emotion/react@11.11.4/dist/emotion-react.umd.min.js" crossorigin></script>
  <script src="https://unpkg.com/@emotion/styled@11.11.5/dist/emotion-styled.umd.min.js" crossorigin></script>

  <!-- MUI v5 (UMD) -->
  <script src="https://unpkg.com/@mui/material@5.15.14/umd/material-ui.development.js" crossorigin></script>
  <script src="https://unpkg.com/@mui/icons-material@5.15.14/umd/material-ui-icons.development.js" crossorigin></script>

  <!-- Papa Parse for CSV -->
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js" crossorigin></script>

  <style>
    html, body, #root { height: 100%; margin: 0; }
    img.chart { width: 100%; height: auto; border-radius: 12px; display: block; background: #f5f5f5; }
    .sticky-footer { position: sticky; bottom: 0; z-index: 10; background: rgba(255,255,255,0.9); backdrop-filter: blur(6px); }
  </style>
</head>
<body>
<div id="root"></div>

<script>
(() => {
  const { createElement: h, useEffect, useMemo, useState } = React;
  const {
    ThemeProvider, createTheme, CssBaseline, Container, Box, Typography, Grid,
    Card, CardHeader, CardContent, CardActions, Button, Rating, LinearProgress,
    Stack, Divider, Chip, Snackbar, Alert, Tooltip
  } = MaterialUI;

  // ========= CONFIG =========
  const TOTAL_CHARTS = 50;
  const PICK_COUNT = 10;
  const CHART_DIR = './charts';               // charts/1.svg ... charts/50.svg
  const INSIGHTS_CSV_PATH = CHART_DIR + '/insights.csv'; // columns: id,insightA,insightB

  // !!! Replace with your public collector endpoint (e.g., ngrok) !!!
  const SUBMIT_URL = 'https://YOUR-NGROK-SUBDOMAIN.ngrok.io/submit';
  // ==========================

  function randSample(n, k) {
    const arr = Array.from({length: n}, (_, i) => i + 1);
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr.slice(0, k);
  }

  function useInsights() {
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    const [rows, setRows] = useState([]);

    useEffect(() => {
      Papa.parse(INSIGHTS_CSV_PATH, {
        download: true,
        header: true,
        skipEmptyLines: true,
        complete: (res) => {
          const valid = [];
          for (const r of res.data) {
            const id = parseInt(r.id, 10);
            if (!isNaN(id) && r.insightA && r.insightB) {
              valid.push({ id, insightA: String(r.insightA), insightB: String(r.insightB) });
            }
          }
          setRows(valid);
          setLoading(false);
        },
        error: (err) => {
          setError(err?.message || 'Failed to load CSV');
          setLoading(false);
        }
      });
    }, []);

    return { loading, error, rows };
  }

  function App() {
    const theme = useMemo(() => createTheme({ palette: { mode: 'light' }, shape: { borderRadius: 16 } }), []);
    const { loading, error, rows } = useInsights();

    const [items, setItems] = useState([]);
    const [submitting, setSubmitting] = useState(false);
    const [snackbar, setSnackbar] = useState(null);

    const allRated = items.length > 0 && items.every(it => it.ratingA && it.ratingB);

    useEffect(() => {
      if (!loading && !error && rows.length) {
        const ids = randSample(Math.min(TOTAL_CHARTS, rows.length), PICK_COUNT);
        const map = new Map(rows.map(r => [r.id, r]));
        const picked = ids.map(id => {
          const rec = map.get(id) || { insightA: `Insight A for #${id}`, insightB: `Insight B for #${id}` };
          return {
            id,
            imgUrl: `${CHART_DIR}/${id}.svg`,
            insightA: rec.insightA,
            insightB: rec.insightB,
            ratingA: null,
            ratingB: null
          };
        });
        setItems(picked);
      }
    }, [loading, error, rows]);

    const progress = useMemo(() => {
      const rated = items.reduce((acc, it) => acc + (it.ratingA ? 1 : 0) + (it.ratingB ? 1 : 0), 0);
      const total = items.length * 2 || 1;
      return Math.round((rated / total) * 100);
    }, [items]);

    function handleRate(index, field, value) {
      setItems(prev => {
        const copy = prev.slice();
        copy[index] = { ...copy[index], [field]: value || 0 };
        return copy;
      });
    }

    async function handleSubmit() {
      if (!allRated) return;

      const payload = {
        submissionId: (crypto && crypto.randomUUID) ? crypto.randomUUID() : `id-${Date.now()}-${Math.random().toString(36).slice(2)}`,
        createdAt: new Date().toISOString(),
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        userAgent: navigator.userAgent,
        selectedCharts: items.map(it => it.id),
        responses: items.map(it => ({
          chartId: it.id,
          insightA: it.insightA,
          ratingA: it.ratingA,
          insightB: it.insightB,
          ratingB: it.ratingB
        }))
      };

      setSubmitting(true);
      try {
        if (!SUBMIT_URL || SUBMIT_URL.includes('YOUR-NGROK-SUBDOMAIN')) {
          throw new Error('SUBMIT_URL not configured yet');
        }
        const res = await fetch(SUBMIT_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });
        if (!res.ok) throw new Error(`Submit failed: ${res.status}`);
        setSnackbar({ severity: 'success', msg: 'Thanks! Your ratings were submitted.' });
      } catch (e) {
        console.warn(e);
        setSnackbar({ severity: 'warning', msg: 'Could not reach server. Check SUBMIT_URL.' });
      } finally {
        setSubmitting(false);
      }
    }

    function handleRefresh() {
      if (rows.length) {
        const ids = randSample(Math.min(TOTAL_CHARTS, rows.length), PICK_COUNT);
        const map = new Map(rows.map(r => [r.id, r]));
        const picked = ids.map(id => {
          const rec = map.get(id) || { insightA: `Insight A for #${id}`, insightB: `Insight B for #${id}` };
          return { id, imgUrl: `${CHART_DIR}/${id}.svg`, insightA: rec.insightA, insightB: rec.insightB, ratingA: null, ratingB: null };
        });
        setItems(picked);
      }
    }

    return h(ThemeProvider, { theme },
      h(CssBaseline, null),
      h(Container, { maxWidth: 'lg', sx: { py: 4 } },
        h(Stack, { spacing: 2 },
          h(Box, null,
            h(Typography, { variant: "h4", sx: { fontWeight: 700 } }, "Chart Insights Rating"),
            h(Typography, { variant: "subtitle1", color: "text.secondary" },
              "Rate Insight A and Insight B for each chart from 1 (Strongly Disagree) to 5 (Strongly Agree).")
          ),

          (loading) && h(Box, null, h(LinearProgress, null), h(Typography, { variant: 'body2', sx: { mt: 1 } }, "Loading charts & insights...")),
          (error) && h(Alert, { severity: "error" }, String(error)),

          (!loading && !error && items.length > 0) && h(Box, null,
            h(Box, { className: 'sticky-footer', sx: { py: 1, mb: 2 } },
              h(Stack, { direction: 'row', alignItems: 'center', spacing: 2 },
                h(Box, { sx: { flex: 1 } },
                  h(LinearProgress, { variant: "determinate", value: progress }),
                  h(Typography, { variant: "caption", color: "text.secondary" }, `${progress}% complete`)
                ),
                h(Tooltip, { title: SUBMIT_URL.includes('YOUR-NGROK-SUBDOMAIN') ? 'Configure SUBMIT_URL to enable server submission' : '' },
                  h(Box, null,
                    h(Button, { variant: "contained", disabled: !allRated || submitting, onClick: handleSubmit },
                      submitting ? "Submitting..." : "Submit")
                  )
                ),
                h(Button, { variant: "text", onClick: handleRefresh }, "Reshuffle 10")
              )
            ),

            h(Grid, { container: true, spacing: 3 },
              items.map((it, idx) =>
                h(Grid, { item: true, xs: 12, md: 6, key: it.id },
                  h(MaterialUI.Card, null,
                    h(CardHeader, { title: `Chart #${it.id}`, subheader: "Rate both insights below" }),
                    h(CardContent, null,
                      h(Box, { sx: { mb: 2 } },
                        h('img', {
                          className: 'chart', src: it.imgUrl, alt: `Chart ${it.id}`, loading: 'lazy',
                          onError: (e) => { e.currentTarget.style.opacity = 0.2; }
                        })
                      ),
                      h(Stack, { spacing: 2 },
                        h(Box, null,
                          h(Typography, { variant: "subtitle2" }, "Insight A"),
                          h(Typography, { variant: "body2", sx: { mb: 1 }, color: "text.secondary" }, it.insightA),
                          h(Rating, {
                            name: `ratingA-${it.id}`,
                            value: it.ratingA || 0,
                            onChange: (_, v) => handleRate(idx, 'ratingA', v || 0)
                          })
                        ),
                        h(Divider, { children: h(Chip, { label: "VS" }) }),
                        h(Box, null,
                          h(Typography, { variant: "subtitle2" }, "Insight B"),
                          h(Typography, { variant: "body2", sx: { mb: 1 }, color: "text.secondary" }, it.insightB),
                          h(Rating, {
                            name: `ratingB-${it.id}`,
                            value: it.ratingB || 0,
                            onChange: (_, v) => handleRate(idx, 'ratingB', v || 0)
                          })
                        )
                      )
                    ),
                    h(CardActions, { sx: { justifyContent: 'flex-end' } },
                      h(Typography, { variant: "caption", color: "text.secondary" },
                        (it.ratingA && it.ratingB) ? `Rated: A=${it.ratingA} · B=${it.ratingB}` : "Not fully rated yet"
                      )
                    )
                  )
                )
              )
            )
          )
        ),
        h(Snackbar, {
          open: !!snackbar, autoHideDuration: 4000,
          onClose: () => setSnackbar(null), anchorOrigin: { vertical: 'bottom', horizontal: 'center' }
        }, snackbar && h(Alert, { severity: snackbar.severity, variant: "filled" }, snackbar.msg))
      )
    );
  }

  const root = ReactDOM.createRoot(document.getElementById('root'));
  root.render(React.createElement(App));
})();
</script>
</body>
</html>